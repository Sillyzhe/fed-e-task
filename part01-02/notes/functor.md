## 函子 Functor

为什么要学函子

目前为止已经学习了函数式编程的一些基础，还没有演示在函数编程中如何把副作用控制在可控的范围内、异常处理、异步操作等。

- 什么是Functor
  - 容器：包含值与值的变形关系（这个变形关系就是函数）
  - 函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有map方法，map方法可以进行一个函数对值进行处理（变形关系）

- 总结
  - 函数式编程的运算不直接操作值，而是由函子完成
  - 函子就是一个车实现了map契约的对象
  - 我们可以把函子想象成一个盒子，这个盒子里封装了一个值
  - 想要处理盒子中的值，我们需要给盒子的map方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理
  - 最终map方法返回一个包含新值的盒子（函子）

### MayBe函子
- 我们在编程过程中可能会遇到很多错误，需要对这些错误做相应的处理
- MayBe函子的作用就是可以对外部的空值情况做处理（控制副作用在允许的范围）

### Either 函子
- Either两者中的任何一个，类似于if...else...的处理
- 异常会让函数变的不纯，Either函子可以用来做异常处理


### IO函子
- IO函子中的_value是一个函数，这里是把函数作为值来处理
- IO函子可以把不纯的动作存储到_value中，延迟执行这个不纯的操作（惰性执行），包装当前的操作（纯）
- 把不纯的操作交给调用者来处理

### Folktale

Task异步执行
- 异步任务的实现过于复杂，我们使用folktale中的Task来演示
- folktale一个标准的函数式变成库
  - 和lodash、ramda不同的是，他没有提供很多功能函数
  - 只提供了一些函数式处理的操作，例如：compose、curry等，一些函子Task、Either、MayBe等

### Pointed函子
- Pointed函子是实现了of静态方法的函子
- of方法是为了避免使用new来创建对象，更深层的含义是of方法用来把值放到上下文Context（把值放到容器中，使用map来处理值）

### Monad（单子）
- Monad函子是可以变扁的Pointed函子，IO(IO(x))
- 一个函子如果具有join和of两个方法并遵守一些定律就是一个Monad